name: 'Terraform Infrastructure'

on:
  push:
    branches:
      - main
      - develop
    paths:
      - 'terraform/**'
  pull_request:
    branches:
      - main
    paths:
      - 'terraform/**'
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'apply'
        type: choice
        options:
          - apply
          - destroy
          - plan-only
      environment:
        description: 'Environment to deploy/destroy'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
          - all-dev
          - all-staging
          - all-prod
      confirm_destroy:
        description: 'Type "DESTROY" to confirm destruction (required for destroy action)'
        required: false
        type: string
      auto_apply:
        description: 'Auto-apply for specific environments (dev only)'
        required: false
        default: false
        type: boolean

permissions:
  id-token: write
  contents: read
  pull-requests: write

env:
  TF_VERSION: '1.5.0'
  AWS_REGION: 'ap-south-1'

jobs:
  terraform-validate:
    name: 'Validate'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Format Check
        run: terraform fmt -check -recursive terraform/
        continue-on-error: false

      - name: Terraform Init
        run: |
          cd terraform
          terraform init -backend=false

      - name: Terraform Validate
        run: |
          cd terraform
          terraform validate

  determine-environments:
    name: 'Determine Target Environments'
    runs-on: ubuntu-latest
    needs: terraform-validate
    outputs:
      environments: ${{ steps.set-environments.outputs.environments }}
      action: ${{ steps.set-action.outputs.action }}
    steps:
      - name: Determine Environments and Actions
        id: set-environments
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            case "${{ github.event.inputs.environment }}" in
              "all-dev")
                echo "environments=[\"dev\"]" >> $GITHUB_OUTPUT
                ;;
              "all-staging")
                echo "environments=[\"staging\"]" >> $GITHUB_OUTPUT
                ;;
              "all-prod")
                echo "environments=[\"prod\"]" >> $GITHUB_OUTPUT
                ;;
              *)
                echo "environments=[\"${{ github.event.inputs.environment }}\"]" >> $GITHUB_OUTPUT
                ;;
            esac
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environments=[\"prod\"]" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "environments=[\"dev\", \"staging\"]" >> $GITHUB_OUTPUT
          else
            echo "environments=[\"dev\"]" >> $GITHUB_OUTPUT
          fi

      - name: Determine Action
        id: set-action
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "action=${{ github.event.inputs.action }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "action=plan-only" >> $GITHUB_OUTPUT
          else
            # Auto-determine based on environment and branch
            case "${{ github.ref }}" in
              "refs/heads/main")
                echo "action=apply" >> $GITHUB_OUTPUT
                ;;
              "refs/heads/develop")
                echo "action=apply" >> $GITHUB_OUTPUT
                ;;
              *)
                echo "action=plan-only" >> $GITHUB_OUTPUT
                ;;
            esac
          fi

  terraform-plan:
    name: 'Plan'
    runs-on: ubuntu-latest
    needs: [terraform-validate, determine-environments]
    if: github.event_name == 'pull_request' || needs.determine-environments.outputs.action == 'plan-only'
    strategy:
      matrix:
        environment: ${{ fromJson(needs.determine-environments.outputs.environments) }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::199570228070:role/oidc-demo-role
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-TerraformPlan-${{ matrix.environment }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        run: |
          cd terraform
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=hello-world-lambda/${{ matrix.environment }}/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="encrypt=true"

      - name: Terraform Plan
        id: plan
        run: |
          cd terraform
          terraform plan \
            -var-file="environments/${{ matrix.environment }}/terraform.tfvars" \
            -out=tfplan-${{ matrix.environment }} \
            -no-color
        continue-on-error: true

      - name: Comment PR
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request'
        env:
          PLAN: "${{ steps.plan.outputs.stdout }}"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const output = `#### Terraform Plan for ${{ matrix.environment }} üìñ
            <details><summary>Show Plan</summary>
            
            \`\`\`
            ${process.env.PLAN}
            \`\`\`
            
            </details>
            
            *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`, Workflow: \`${{ github.workflow }}\`*`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

  terraform-apply:
    name: 'Apply Infrastructure'
    runs-on: ubuntu-latest
    needs: [terraform-validate, determine-environments]
    if: |
      needs.determine-environments.outputs.action == 'apply' && (
        github.ref == 'refs/heads/main' || 
        github.ref == 'refs/heads/develop' || 
        github.event_name == 'workflow_dispatch'
      )
    strategy:
      matrix:
        environment: ${{ fromJson(needs.determine-environments.outputs.environments) }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Environment-Specific Pre-Apply Checks
        run: |
          echo "üéØ Applying infrastructure for environment: ${{ matrix.environment }}"
          
          case "${{ matrix.environment }}" in
            "prod")
              echo "üîí Production deployment - Enhanced safety checks"
              echo "üìã Deployment will include:"
              echo "  - High availability configuration"
              echo "  - Enhanced monitoring and alerting"
              echo "  - Production-grade security settings"
              ;;
            "staging")
              echo "üß™ Staging deployment - Production-like testing"
              echo "üìã Deployment will include:"
              echo "  - Production-like configuration"
              echo "  - Full monitoring stack"
              echo "  - Integration testing setup"
              ;;
            "dev")
              echo "üöÄ Development deployment - Rapid iteration"
              echo "üìã Deployment will include:"
              echo "  - Cost-optimized configuration"
              echo "  - Basic monitoring"
              echo "  - Development-friendly settings"
              ;;
          esac

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::199570228070:role/oidc-demo-role
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-TerraformApply-${{ matrix.environment }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        run: |
          cd terraform
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=hello-world-lambda/${{ matrix.environment }}/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="encrypt=true"

      - name: Terraform Plan
        run: |
          cd terraform
          echo "üìã Planning Terraform changes for ${{ matrix.environment }}..."
          terraform plan \
            -var-file="environments/${{ matrix.environment }}/terraform.tfvars" \
            -out=tfplan-${{ matrix.environment }}

      - name: Terraform Apply
        run: |
          cd terraform
          echo "üöÄ Applying Terraform changes for ${{ matrix.environment }}..."
          terraform apply tfplan-${{ matrix.environment }}

      - name: Environment-Specific Post-Apply Actions
        run: |
          echo "‚úÖ Infrastructure deployment completed for ${{ matrix.environment }}"
          
          case "${{ matrix.environment }}" in
            "prod")
              echo "üéâ Production environment is live!"
              echo "üîó Monitor at: https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }}"
              echo "üõ°Ô∏è Security: All production security measures are active"
              ;;
            "staging")
              echo "üß™ Staging environment ready for testing!"
              echo "üîó Test your changes before promoting to production"
              ;;
            "dev")
              echo "üöÄ Development environment ready!"
              echo "üí° Perfect for rapid development and testing"
              ;;
          esac

  terraform-destroy:
    name: 'Destroy Infrastructure'
    runs-on: ubuntu-latest
    needs: [terraform-validate, determine-environments]
    if: needs.determine-environments.outputs.action == 'destroy' && github.event_name == 'workflow_dispatch'
    strategy:
      matrix:
        environment: ${{ fromJson(needs.determine-environments.outputs.environments) }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate Destroy Confirmation
        run: |
          if [[ "${{ github.event.inputs.confirm_destroy }}" != "DESTROY" ]]; then
            echo "‚ùå Destroy confirmation failed!"
            echo "üí° To destroy infrastructure, you must type 'DESTROY' in the confirm_destroy field"
            echo "üîí This is a safety measure to prevent accidental destruction"
            exit 1
          fi
          echo "‚úÖ Destroy confirmation validated for ${{ matrix.environment }}"

      - name: Environment-Specific Destroy Warnings
        run: |
          echo "‚ö†Ô∏è  WARNING: About to destroy ${{ matrix.environment }} environment!"
          
          case "${{ matrix.environment }}" in
            "prod")
              echo "üö® CRITICAL: Destroying PRODUCTION environment!"
              echo "üí• This will delete ALL production resources!"
              echo "üìä Impact: Customer-facing services will be unavailable"
              echo "üîÑ Recovery: Will require full redeployment"
              ;;
            "staging")
              echo "‚ö†Ô∏è  Destroying STAGING environment"
              echo "üß™ Impact: Testing environment will be unavailable"
              echo "üîÑ Recovery: Can be recreated quickly"
              ;;
            "dev")
              echo "üóëÔ∏è  Destroying DEVELOPMENT environment"
              echo "üíª Impact: Development environment will be unavailable"
              echo "üîÑ Recovery: Can be recreated immediately"
              ;;
          esac
          
          echo ""
          echo "‚è∞ Proceeding with destruction in 10 seconds..."
          sleep 10

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::199570228070:role/oidc-demo-role
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-TerraformDestroy-${{ matrix.environment }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        run: |
          cd terraform
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=hello-world-lambda/${{ matrix.environment }}/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="encrypt=true"

      - name: Terraform Destroy Plan
        run: |
          cd terraform
          echo "üóëÔ∏è Planning Terraform destruction for ${{ matrix.environment }}..."
          terraform plan \
            -var-file="environments/${{ matrix.environment }}/terraform.tfvars" \
            -destroy \
            -out=tfplan-destroy-${{ matrix.environment }}

      - name: Terraform Destroy
        run: |
          cd terraform
          echo "üí• Destroying Terraform infrastructure for ${{ matrix.environment }}..."
          echo "‚ö†Ô∏è This will permanently delete all resources!"
          terraform apply tfplan-destroy-${{ matrix.environment }}

      - name: Environment-Specific Post-Destroy Actions
        run: |
          echo "üí• Infrastructure destruction completed for ${{ matrix.environment }}"
          
          case "${{ matrix.environment }}" in
            "prod")
              echo "üö® PRODUCTION ENVIRONMENT DESTROYED!"
              echo "üìä All production resources have been permanently deleted"
              echo "üîÑ To restore: Run apply action with prod environment"
              ;;
            "staging")
              echo "üß™ Staging environment destroyed"
              echo "üîÑ To restore: Run apply action with staging environment"
              ;;
            "dev")
              echo "üíª Development environment destroyed"
              echo "üîÑ To restore: Run apply action with dev environment"
              ;;
          esac
          
          echo ""
          echo "üí° Next steps:"
          echo "1. Run apply action to recreate resources"
          echo "2. Update Terraform state if needed: terraform refresh"

      - name: Clean up plan files
        run: |
          cd terraform
          rm -f tfplan-* || true

  output-results:
    name: 'Output Results'
    runs-on: ubuntu-latest
    needs: [determine-environments, terraform-apply, terraform-destroy]
    if: always() && (needs.terraform-apply.result != 'skipped' || needs.terraform-destroy.result != 'skipped')
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::199570228070:role/oidc-demo-role
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-OutputResults

      - name: Generate Deployment Summary
        run: |
          echo "üìä DEPLOYMENT SUMMARY"
          echo "===================="
          echo "Action: ${{ needs.determine-environments.outputs.action }}"
          echo "Environments: ${{ needs.determine-environments.outputs.environments }}"
          echo "Trigger: ${{ github.event_name }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Actor: ${{ github.actor }}"
          echo ""
          
          if [[ "${{ needs.determine-environments.outputs.action }}" == "apply" ]]; then
            echo "‚úÖ INFRASTRUCTURE DEPLOYED"
            echo "=========================="
            
            # Get deployment details for each environment
            for env in $(echo '${{ needs.determine-environments.outputs.environments }}' | jq -r '.[]'); do
              echo ""
              echo "üéØ Environment: $env"
              echo "----------------"
              
              # Try to get Lambda function info
              LAMBDA_NAME="hello-world-lambda-${env}-hello-world"
              if aws lambda get-function --function-name "$LAMBDA_NAME" --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
                echo "‚úÖ Lambda Function: $LAMBDA_NAME"
              else
                echo "‚ö†Ô∏è Lambda Function: Not found or not accessible"
              fi
              
              # Try to get API Gateway info
              API_NAME="hello-world-lambda-${env}-api"
              API_ID=$(aws apigateway get-rest-apis --query "items[?name=='$API_NAME'].id" --output text --region ${{ env.AWS_REGION }} 2>/dev/null || echo "")
              if [[ ! -z "$API_ID" && "$API_ID" != "None" ]]; then
                API_URL="https://${API_ID}.execute-api.${{ env.AWS_REGION }}.amazonaws.com/${env}"
                echo "‚úÖ API Gateway: $API_URL"
              else
                echo "‚ö†Ô∏è API Gateway: Not found or not accessible"
              fi
              
              echo "üîó Useful Links:"
              echo "  - AWS Console: https://console.aws.amazon.com/"
              echo "  - Lambda: https://console.aws.amazon.com/lambda/home?region=${{ env.AWS_REGION }}"
              echo "  - API Gateway: https://console.aws.amazon.com/apigateway/home?region=${{ env.AWS_REGION }}"
              echo "  - CloudWatch: https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }}"
            done
            
          elif [[ "${{ needs.determine-environments.outputs.action }}" == "destroy" ]]; then
            echo "üí• INFRASTRUCTURE DESTROYED"
            echo "==========================="
            echo "All resources have been permanently deleted!"
            echo "üí° You can recreate them by running the apply action again"
          fi