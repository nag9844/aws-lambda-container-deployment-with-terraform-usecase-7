name: Build and Push Docker Image

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod
      image_tag:
        description: 'Docker image tag'
        required: false
        default: 'latest'
        type: string
  push:
    branches:
      - main
    paths:
      - 'src/**'
  pull_request:
    branches:
      - main
    paths:
      - 'src/**'

env:
  AWS_REGION: ap-south-1

permissions:
  id-token: write
  contents: read

jobs:
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'dev' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::199570228070:role/oidc-demo-role
          role-session-name: GitHubActions-Build-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}
      

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get ECR Repository URI
        id: get-ecr-uri
        run: |
          # Get ECR repository URI from AWS
          REPO_NAME="hello-world-lambda-${{ github.event.inputs.environment || 'dev' }}"
          ECR_URI=$(aws ecr describe-repositories --repository-names $REPO_NAME --query 'repositories[0].repositoryUri' --output text)
          echo "ecr_uri=$ECR_URI" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ ECR Repository URI: $ECR_URI"

      - name: Verify ECR Repository Exists
        run: |
          REPO_NAME="hello-world-lambda-${{ github.event.inputs.environment || 'dev' }}"
          echo "ðŸ” Verifying ECR repository exists..."
          
          if aws ecr describe-repositories --repository-names $REPO_NAME --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            echo "âœ… ECR repository '$REPO_NAME' exists"
          else
            echo "âŒ ECR repository '$REPO_NAME' does not exist!"
            echo "Please run the ECR workflow first to create the repository"
            exit 1
          fi

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.get-ecr-uri.outputs.ecr_uri }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=${{ github.event.inputs.image_tag || 'latest' }}
            type=raw,value={{date 'YYYYMMDD-HHmmss'}}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image locally first
        run: |
          echo "ðŸ”¨ Building Docker image locally for validation..."
          cd src
          docker build -t test-lambda-image .
          echo "âœ… Local build successful"

      - name: Test Docker image locally
        run: |
          echo "ðŸ§ª Testing Docker image locally..."
          
          # Test that the image can run
          docker run --rm test-lambda-image python -c "import app; print('âœ… App module imports successfully')"
          
          # Test that boto3 is available
          docker run --rm test-lambda-image python -c "import boto3; print('âœ… boto3 is available')"
          
          echo "âœ… Local image tests passed"

      - name: Build and push Docker image to ECR
        uses: docker/build-push-action@v5
        with:
          context: ./src
          file: ./src/Dockerfile
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      - name: Verify image was pushed successfully
        if: github.event_name != 'pull_request'
        run: |
          echo "ðŸ” Verifying image was pushed to ECR..."
          IMAGE_URI="${{ steps.get-ecr-uri.outputs.ecr_uri }}:${{ github.event.inputs.image_tag || 'latest' }}"
          
          # Wait a moment for ECR to register the image
          sleep 10
          
          # Check if image exists in ECR
          if aws ecr describe-images --repository-name "hello-world-lambda-${{ github.event.inputs.environment || 'dev' }}" --image-ids imageTag="${{ github.event.inputs.image_tag || 'latest' }}" --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            echo "âœ… Image successfully pushed to ECR: $IMAGE_URI"
          else
            echo "âŒ Image not found in ECR after push!"
            echo "Listing all images in repository:"
            aws ecr list-images --repository-name "hello-world-lambda-${{ github.event.inputs.environment || 'dev' }}" --region ${{ env.AWS_REGION }}
            exit 1
          fi

      - name: Image vulnerability scan
        if: github.event_name != 'pull_request'
        run: |
          echo "ðŸ”’ Running security scan on Docker image..."
          
          # Install Trivy
          sudo apt-get update
          sudo apt-get install wget apt-transport-https gnupg lsb-release
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
          sudo apt-get update
          sudo apt-get install trivy
          
          # Scan the image
          IMAGE_URI="${{ steps.get-ecr-uri.outputs.ecr_uri }}:${{ github.event.inputs.image_tag || 'latest' }}"
          echo "ðŸ” Scanning image: $IMAGE_URI"
          trivy image --exit-code 0 --severity HIGH,CRITICAL $IMAGE_URI

      - name: Update Lambda Function with New Image
        if: github.event_name != 'pull_request'
        run: |
          FUNCTION_NAME="hello-world-lambda-${{ github.event.inputs.environment || 'dev' }}"
          IMAGE_URI="${{ steps.get-ecr-uri.outputs.ecr_uri }}:${{ github.event.inputs.image_tag || 'latest' }}"
          
          echo "ðŸš€ Updating Lambda function: $FUNCTION_NAME"
          echo "ðŸ“¦ Using image: $IMAGE_URI"
          
          # Function to check if function exists
          function_exists() {
            aws lambda get-function --function-name $1 --region ${{ env.AWS_REGION }} >/dev/null 2>&1
            return $?
          }
          
          # Function to wait for function deletion
          wait_for_deletion() {
            echo "â³ Waiting for function deletion to complete..."
            local max_attempts=30
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              if ! function_exists $FUNCTION_NAME; then
                echo "âœ… Function successfully deleted after $attempt attempts"
                return 0
              fi
              echo "ðŸ”„ Attempt $attempt/$max_attempts: Function still exists, waiting..."
              sleep 5
              attempt=$((attempt + 1))
            done
            
            echo "âŒ ERROR: Function deletion timed out after $max_attempts attempts"
            return 1
          }
          
          # Function to wait for function update
          wait_for_update() {
            echo "â³ Waiting for function update to complete..."
            local max_attempts=30
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              STATUS=$(aws lambda get-function --function-name $FUNCTION_NAME --query 'Configuration.State' --output text --region ${{ env.AWS_REGION }} 2>/dev/null || echo "NotFound")
              LAST_UPDATE_STATUS=$(aws lambda get-function --function-name $FUNCTION_NAME --query 'Configuration.LastUpdateStatus' --output text --region ${{ env.AWS_REGION }} 2>/dev/null || echo "Unknown")
              
              if [ "$STATUS" = "Active" ] && [ "$LAST_UPDATE_STATUS" = "Successful" ]; then
                echo "âœ… Function is now active and update successful after $attempt attempts"
                return 0
              fi
              echo "ðŸ”„ Attempt $attempt/$max_attempts: Function status is $STATUS, update status is $LAST_UPDATE_STATUS, waiting..."
              sleep 10
              attempt=$((attempt + 1))
            done
            
            echo "âŒ ERROR: Function update timed out after $max_attempts attempts"
            return 1
          }
          
          # Check if function exists first
          if function_exists $FUNCTION_NAME; then
            # Check current function configuration
            CURRENT_PACKAGE_TYPE=$(aws lambda get-function --function-name $FUNCTION_NAME --query 'Configuration.PackageType' --output text --region ${{ env.AWS_REGION }})
            echo "ðŸ“‹ Current package type: $CURRENT_PACKAGE_TYPE"
            
            if [ "$CURRENT_PACKAGE_TYPE" = "Zip" ]; then
              echo "ðŸ”„ Function is currently ZIP-based, converting to container-based..."
              
              # Get current function configuration
              CURRENT_CONFIG=$(aws lambda get-function-configuration --function-name $FUNCTION_NAME --region ${{ env.AWS_REGION }})
              ROLE_ARN=$(echo $CURRENT_CONFIG | jq -r '.Role')
              TIMEOUT=$(echo $CURRENT_CONFIG | jq -r '.Timeout')
              MEMORY_SIZE=$(echo $CURRENT_CONFIG | jq -r '.MemorySize')
              
              # Extract environment variables and save to file
              echo "ðŸ’¾ Extracting environment variables..."
              echo $CURRENT_CONFIG | jq -c '.Environment.Variables // {}' > /tmp/env_vars.json
              ENV_VARS_CONTENT=$(cat /tmp/env_vars.json)
              
              echo "ðŸ’¾ Backing up current function configuration..."
              echo "ðŸ”‘ Role: $ROLE_ARN"
              echo "â±ï¸ Timeout: $TIMEOUT"
              echo "ðŸ’¾ Memory: $MEMORY_SIZE"
              echo "ðŸŒ Environment Variables: $ENV_VARS_CONTENT"
              
              # Delete the existing function
              echo "ðŸ—‘ï¸ Deleting existing ZIP-based function..."
              aws lambda delete-function --function-name $FUNCTION_NAME --region ${{ env.AWS_REGION }}
              
              # Wait for deletion to complete with proper verification
              if ! wait_for_deletion; then
                echo "âŒ ERROR: Failed to delete function, aborting conversion"
                exit 1
              fi
              
              # Create new container-based function with proper environment variables
              echo "ðŸ†• Creating new container-based function..."
              if [ "$ENV_VARS_CONTENT" = "{}" ] || [ "$ENV_VARS_CONTENT" = "null" ]; then
                # No environment variables
                echo "ðŸ“ Creating function without environment variables..."
                aws lambda create-function \
                  --function-name $FUNCTION_NAME \
                  --role $ROLE_ARN \
                  --code ImageUri=$IMAGE_URI \
                  --package-type Image \
                  --timeout $TIMEOUT \
                  --memory-size $MEMORY_SIZE \
                  --region ${{ env.AWS_REGION }}
              else
                # With environment variables - use file-based approach
                echo "ðŸ“ Creating function with environment variables..."
                
                # Create environment variables in the correct format for AWS CLI
                cat > /tmp/env_config.json << EOF
          {
            "Variables": $(cat /tmp/env_vars.json)
          }
          EOF
                
                echo "ðŸ“„ Environment config file content:"
                cat /tmp/env_config.json
                
                aws lambda create-function \
                  --function-name $FUNCTION_NAME \
                  --role $ROLE_ARN \
                  --code ImageUri=$IMAGE_URI \
                  --package-type Image \
                  --timeout $TIMEOUT \
                  --memory-size $MEMORY_SIZE \
                  --environment file:///tmp/env_config.json \
                  --region ${{ env.AWS_REGION }}
              fi
              
              # Wait for function to be active
              echo "â³ Waiting for function to become active..."
              if ! wait_for_update; then
                echo "âŒ ERROR: Function creation failed"
                exit 1
              fi
                
            else
              echo "ðŸ³ Function is already container-based, updating image..."
              # Function is already using Image package type, just update the code
              aws lambda update-function-code \
                --function-name $FUNCTION_NAME \
                --image-uri $IMAGE_URI \
                --region ${{ env.AWS_REGION }}
              
              # Wait for the update to complete
              echo "â³ Waiting for function update to complete..."
              if ! wait_for_update; then
                echo "âŒ ERROR: Function update failed"
                exit 1
              fi
            fi
          else
            echo "âŒ Function does not exist, creating new container-based function..."
            # Function doesn't exist, create new container-based function
            # We'll need to get the IAM role from Terraform state or create a basic one
            echo "âŒ ERROR: Function does not exist and we cannot determine the IAM role"
            echo "Please ensure the Lambda function exists before running this workflow"
            exit 1
          fi
          
          echo "ðŸŽ‰ Lambda function conversion completed successfully"
          
          # Verify the final state
          if function_exists $FUNCTION_NAME; then
            FINAL_PACKAGE_TYPE=$(aws lambda get-function --function-name $FUNCTION_NAME --query 'Configuration.PackageType' --output text --region ${{ env.AWS_REGION }})
            FINAL_IMAGE_URI=$(aws lambda get-function --function-name $FUNCTION_NAME --query 'Code.ImageUri' --output text --region ${{ env.AWS_REGION }})
            FINAL_STATE=$(aws lambda get-function --function-name $FUNCTION_NAME --query 'Configuration.State' --output text --region ${{ env.AWS_REGION }})
            echo "ðŸ“¦ Final package type: $FINAL_PACKAGE_TYPE"
            echo "ðŸ–¼ï¸ Final image URI: $FINAL_IMAGE_URI"
            echo "ðŸŸ¢ Final state: $FINAL_STATE"
            
            # Test the function
            echo "ðŸ§ª Testing the updated function..."
            TEST_RESULT=$(aws lambda invoke \
              --function-name $FUNCTION_NAME \
              --payload '{"httpMethod":"GET","path":"/","headers":{"Accept":"application/json"}}' \
              --region ${{ env.AWS_REGION }} \
              response.json)
            
            if [ $? -eq 0 ]; then
              echo "âœ… Function test successful!"
              echo "ðŸ“„ Response preview:"
              head -c 200 response.json
              echo ""
              echo "ðŸŒ You can now test your updated function via API Gateway!"
            else
              echo "âš ï¸ Function test failed, but deployment completed"
            fi
          else
            echo "âŒ ERROR: Function verification failed - function does not exist after creation"
            exit 1
          fi

    outputs:
      image_uri: ${{ steps.get-ecr-uri.outputs.ecr_uri }}:${{ github.event.inputs.image_tag || 'latest' }}