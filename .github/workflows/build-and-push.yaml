name: Build and Push Docker Image

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod
      image_tag:
        description: 'Docker image tag'
        required: false
        default: 'latest'
        type: string
  push:
    branches:
      - main
    paths:
      - 'src/**'
  pull_request:
    branches:
      - main
    paths:
      - 'src/**'

env:
  AWS_REGION: ap-south-1

permissions:
  id-token: write
  contents: read

jobs:
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'dev' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::199570228070:role/oidc-demo-role
          role-session-name: GitHubActions-Build-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get ECR Repository URI
        id: get-ecr-uri
        run: |
          # Get ECR repository URI from AWS
          REPO_NAME="hello-world-lambda-${{ github.event.inputs.environment || 'dev' }}"
          ECR_URI=$(aws ecr describe-repositories --repository-names $REPO_NAME --query 'repositories[0].repositoryUri' --output text)
          echo "ecr_uri=$ECR_URI" >> $GITHUB_OUTPUT
          echo "ECR Repository URI: $ECR_URI"

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.get-ecr-uri.outputs.ecr_uri }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=${{ github.event.inputs.image_tag || 'latest' }}
            type=raw,value={{date 'YYYYMMDD-HHmmss'}}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./src
          file: ./src/Dockerfile
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      - name: Image vulnerability scan
        if: github.event_name != 'pull_request'
        run: |
          # Install Trivy
          sudo apt-get update
          sudo apt-get install wget apt-transport-https gnupg lsb-release
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
          sudo apt-get update
          sudo apt-get install trivy
          
          # Scan the image
          trivy image --exit-code 0 --severity HIGH,CRITICAL ${{ steps.get-ecr-uri.outputs.ecr_uri }}:${{ github.event.inputs.image_tag || 'latest' }}

      - name: Update Lambda Function with New Image
        if: github.event_name != 'pull_request'
        run: |
          FUNCTION_NAME="hello-world-lambda-${{ github.event.inputs.environment || 'dev' }}"
          IMAGE_URI="${{ steps.get-ecr-uri.outputs.ecr_uri }}:${{ github.event.inputs.image_tag || 'latest' }}"
          
          echo "üöÄ Updating Lambda function: $FUNCTION_NAME"
          echo "üì¶ Using image: $IMAGE_URI"
          
          # Function to check if function exists
          function_exists() {
            aws lambda get-function --function-name $1 --region ${{ env.AWS_REGION }} >/dev/null 2>&1
            return $?
          }
          
          # Function to wait for function deletion
          wait_for_deletion() {
            echo "‚è≥ Waiting for function deletion to complete..."
            local max_attempts=30
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              if ! function_exists $FUNCTION_NAME; then
                echo "‚úÖ Function successfully deleted after $attempt attempts"
                return 0
              fi
              echo "üîÑ Attempt $attempt/$max_attempts: Function still exists, waiting..."
              sleep 5
              attempt=$((attempt + 1))
            done
            
            echo "‚ùå ERROR: Function deletion timed out after $max_attempts attempts"
            return 1
          }
          
          # Function to wait for function update
          wait_for_update() {
            echo "‚è≥ Waiting for function update to complete..."
            local max_attempts=20
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              STATUS=$(aws lambda get-function --function-name $FUNCTION_NAME --query 'Configuration.State' --output text --region ${{ env.AWS_REGION }})
              if [ "$STATUS" = "Active" ]; then
                echo "‚úÖ Function is now active after $attempt attempts"
                return 0
              fi
              echo "üîÑ Attempt $attempt/$max_attempts: Function status is $STATUS, waiting..."
              sleep 10
              attempt=$((attempt + 1))
            done
            
            echo "‚ùå ERROR: Function update timed out after $max_attempts attempts"
            return 1
          }
          
          # Check if function exists first
          if function_exists $FUNCTION_NAME; then
            # Check current function configuration
            CURRENT_PACKAGE_TYPE=$(aws lambda get-function --function-name $FUNCTION_NAME --query 'Configuration.PackageType' --output text --region ${{ env.AWS_REGION }})
            echo "üìã Current package type: $CURRENT_PACKAGE_TYPE"
            
            if [ "$CURRENT_PACKAGE_TYPE" = "Zip" ]; then
              echo "üîÑ Function is currently ZIP-based, converting to container-based..."
              
              # Get current function configuration
              CURRENT_CONFIG=$(aws lambda get-function-configuration --function-name $FUNCTION_NAME --region ${{ env.AWS_REGION }})
              ROLE_ARN=$(echo $CURRENT_CONFIG | jq -r '.Role')
              TIMEOUT=$(echo $CURRENT_CONFIG | jq -r '.Timeout')
              MEMORY_SIZE=$(echo $CURRENT_CONFIG | jq -r '.MemorySize')
              
              # Extract environment variables and convert to proper format
              ENV_VARS_JSON=$(echo $CURRENT_CONFIG | jq -c '.Environment.Variables // {}')
              
              echo "üíæ Backing up current function configuration..."
              echo "üîë Role: $ROLE_ARN"
              echo "‚è±Ô∏è Timeout: $TIMEOUT"
              echo "üíæ Memory: $MEMORY_SIZE"
              echo "üåç Environment Variables: $ENV_VARS_JSON"
              
              # Delete the existing function
              echo "üóëÔ∏è Deleting existing ZIP-based function..."
              aws lambda delete-function --function-name $FUNCTION_NAME --region ${{ env.AWS_REGION }}
              
              # Wait for deletion to complete with proper verification
              if ! wait_for_deletion; then
                echo "‚ùå ERROR: Failed to delete function, aborting conversion"
                exit 1
              fi
              
              # Create new container-based function with proper environment variables
              echo "üÜï Creating new container-based function..."
              if [ "$ENV_VARS_JSON" = "{}" ] || [ "$ENV_VARS_JSON" = "null" ]; then
                # No environment variables
                echo "üìù Creating function without environment variables..."
                aws lambda create-function \
                  --function-name $FUNCTION_NAME \
                  --role $ROLE_ARN \
                  --code ImageUri=$IMAGE_URI \
                  --package-type Image \
                  --timeout $TIMEOUT \
                  --memory-size $MEMORY_SIZE \
                  --region ${{ env.AWS_REGION }}
              else
                # With environment variables - write to file first to avoid shell parsing issues
                echo "üìù Creating function with environment variables..."
                echo "$ENV_VARS_JSON" > /tmp/env_vars.json
                
                aws lambda create-function \
                  --function-name $FUNCTION_NAME \
                  --role $ROLE_ARN \
                  --code ImageUri=$IMAGE_URI \
                  --package-type Image \
                  --timeout $TIMEOUT \
                  --memory-size $MEMORY_SIZE \
                  --environment file:///tmp/env_vars.json \
                  --region ${{ env.AWS_REGION }}
              fi
              
              # Wait for function to be active
              echo "‚è≥ Waiting for function to become active..."
              if ! wait_for_update; then
                echo "‚ùå ERROR: Function creation failed"
                exit 1
              fi
                
            else
              echo "üê≥ Function is already container-based, updating image..."
              # Function is already using Image package type, just update the code
              aws lambda update-function-code \
                --function-name $FUNCTION_NAME \
                --image-uri $IMAGE_URI \
                --region ${{ env.AWS_REGION }}
              
              # Wait for the update to complete
              echo "‚è≥ Waiting for function update to complete..."
              if ! wait_for_update; then
                echo "‚ùå ERROR: Function update failed"
                exit 1
              fi
            fi
          else
            echo "‚ùå Function does not exist, creating new container-based function..."
            # Function doesn't exist, create new container-based function
            # We'll need to get the IAM role from Terraform state or create a basic one
            echo "‚ùå ERROR: Function does not exist and we cannot determine the IAM role"
            echo "Please ensure the Lambda function exists before running this workflow"
            exit 1
          fi
          
          echo "üéâ Lambda function conversion completed successfully"
          
          # Verify the final state
          if function_exists $FUNCTION_NAME; then
            FINAL_PACKAGE_TYPE=$(aws lambda get-function --function-name $FUNCTION_NAME --query 'Configuration.PackageType' --output text --region ${{ env.AWS_REGION }})
            FINAL_IMAGE_URI=$(aws lambda get-function --function-name $FUNCTION_NAME --query 'Code.ImageUri' --output text --region ${{ env.AWS_REGION }})
            FINAL_STATE=$(aws lambda get-function --function-name $FUNCTION_NAME --query 'Configuration.State' --output text --region ${{ env.AWS_REGION }})
            echo "üì¶ Final package type: $FINAL_PACKAGE_TYPE"
            echo "üñºÔ∏è Final image URI: $FINAL_IMAGE_URI"
            echo "üü¢ Final state: $FINAL_STATE"
            
            # Test the function
            echo "üß™ Testing the updated function..."
            TEST_RESULT=$(aws lambda invoke \
              --function-name $FUNCTION_NAME \
              --payload '{"httpMethod":"GET","path":"/","headers":{"Accept":"application/json"}}' \
              --region ${{ env.AWS_REGION }} \
              response.json)
            
            if [ $? -eq 0 ]; then
              echo "‚úÖ Function test successful!"
              echo "üìÑ Response preview:"
              head -c 200 response.json
              echo ""
              echo "üåê You can now test your updated function via API Gateway!"
            else
              echo "‚ö†Ô∏è Function test failed, but deployment completed"
            fi
          else
            echo "‚ùå ERROR: Function verification failed - function does not exist after creation"
            exit 1
          fi

    outputs:
      image_uri: ${{ steps.get-ecr-uri.outputs.ecr_uri }}:${{ github.event.inputs.image_tag || 'latest' }}