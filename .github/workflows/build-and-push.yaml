name: Build and Push Docker Image

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod
      image_tag:
        description: 'Docker image tag'
        required: false
        default: 'latest'
        type: string
  push:
    branches:
      - main
    paths:
      - 'src/**'
  pull_request:
    branches:
      - main
    paths:
      - 'src/**'

env:
  AWS_REGION: ap-south-1

permissions:
  id-token: write
  contents: read

jobs:
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'dev' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::199570228070:role/oidc-demo-role
          role-session-name: GitHubActions-Build-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get ECR Repository URI
        id: get-ecr-uri
        run: |
          # Get ECR repository URI from AWS
          REPO_NAME="hello-world-lambda-${{ github.event.inputs.environment || 'dev' }}"
          ECR_URI=$(aws ecr describe-repositories --repository-names $REPO_NAME --query 'repositories[0].repositoryUri' --output text)
          echo "ecr_uri=$ECR_URI" >> $GITHUB_OUTPUT
          echo "📦 ECR Repository URI: $ECR_URI"

      - name: Verify ECR Repository Exists
        run: |
          REPO_NAME="hello-world-lambda-${{ github.event.inputs.environment || 'dev' }}"
          echo "🔍 Verifying ECR repository exists..."
          
          if aws ecr describe-repositories --repository-names $REPO_NAME --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            echo "✅ ECR repository '$REPO_NAME' exists"
          else
            echo "❌ ECR repository '$REPO_NAME' does not exist!"
            echo "Please run the ECR workflow first to create the repository"
            exit 1
          fi

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.get-ecr-uri.outputs.ecr_uri }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=${{ github.event.inputs.image_tag || 'latest' }}
            type=raw,value={{date 'YYYYMMDD-HHmmss'}}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Validate Python Code Before Building
        run: |
          echo "🔍 Validating Python code syntax and imports..."
          cd src
          
          # Check Python syntax
          echo "📝 Checking Python syntax..."
          python3 -m py_compile app.py
          echo "✅ Python syntax is valid"
          
          # Check if required modules can be imported
          echo "📦 Testing module imports..."
          python3 -c "
          import json
          import logging
          print('✅ Standard library imports successful')
          "
          
          # Test the handler function structure
          echo "🎯 Validating handler function..."
          python3 -c "
          import sys
          sys.path.insert(0, '.')
          import app
          
          # Check if lambda_handler exists
          if not hasattr(app, 'lambda_handler'):
              print('❌ lambda_handler function not found')
              sys.exit(1)
          
          # Check if it's callable
          if not callable(app.lambda_handler):
              print('❌ lambda_handler is not callable')
              sys.exit(1)
          
          print('✅ lambda_handler function is valid')
          "
          
          echo "✅ All Python validation checks passed"

      - name: Build Docker image locally first
        run: |
          echo "🔨 Building Docker image locally for validation..."
          cd src
          docker build -t test-lambda-image .
          echo "✅ Local build successful"

      - name: Validate Docker Image Structure
        run: |
          echo "🧪 Validating Docker image structure..."
          
          # Check that the image was built successfully
          if docker images test-lambda-image | grep -q test-lambda-image; then
            echo "✅ Docker image exists"
          else
            echo "❌ Docker image not found"
            exit 1
          fi
          
          # Check image size
          IMAGE_SIZE=$(docker images test-lambda-image --format "table {{.Size}}" | tail -n 1)
          echo "📊 Image size: $IMAGE_SIZE"
          
          # Verify the image contains our files
          echo "📁 Checking image contents..."
          docker run --rm --entrypoint="" test-lambda-image ls -la /var/task/
          
          # Check that Python files are present
          echo "🐍 Verifying Python files..."
          if docker run --rm --entrypoint="" test-lambda-image test -f /var/task/app.py; then
            echo "✅ app.py found in image"
          else
            echo "❌ app.py not found in image"
            exit 1
          fi
          
          # Check requirements.txt if it exists
          if docker run --rm --entrypoint="" test-lambda-image test -f /var/task/requirements.txt; then
            echo "✅ requirements.txt found in image"
            echo "📋 Requirements content:"
            docker run --rm --entrypoint="" test-lambda-image cat /var/task/requirements.txt
          else
            echo "ℹ️ requirements.txt not found (optional)"
          fi
          
          echo "✅ Docker image structure validation passed"

      - name: Test Python Environment in Container
        run: |
          echo "🐍 Testing Python environment in container..."
          
          # Test Python version
          echo "📋 Python version:"
          docker run --rm --entrypoint="" test-lambda-image python --version
          
          # Test that our module can be imported
          echo "📦 Testing module import in container..."
          docker run --rm --entrypoint="" test-lambda-image python -c "
          import sys
          sys.path.insert(0, '/var/task')
          try:
              import app
              print('✅ App module imports successfully in container')
          except Exception as e:
              print(f'❌ App module import failed: {e}')
              sys.exit(1)
          "
          
          # Test boto3 availability (should be included in Lambda base image)
          echo "🔧 Testing boto3 availability..."
          docker run --rm --entrypoint="" test-lambda-image python -c "
          try:
              import boto3
              print('✅ boto3 is available')
              print(f'boto3 version: {boto3.__version__}')
          except Exception as e:
              print(f'❌ boto3 import failed: {e}')
              sys.exit(1)
          "
          
          # Test handler function exists and has correct signature
          echo "🎯 Testing handler function..."
          docker run --rm --entrypoint="" test-lambda-image python -c "
          import sys
          import inspect
          sys.path.insert(0, '/var/task')
          
          try:
              import app
              
              # Check if handler exists
              if not hasattr(app, 'lambda_handler'):
                  print('❌ lambda_handler function not found')
                  sys.exit(1)
              
              # Check function signature
              sig = inspect.signature(app.lambda_handler)
              params = list(sig.parameters.keys())
              
              if len(params) != 2:
                  print(f'❌ lambda_handler should have 2 parameters, found {len(params)}: {params}')
                  sys.exit(1)
              
              print(f'✅ lambda_handler function has correct signature: {params}')
              print('✅ All container tests passed')
              
          except Exception as e:
              print(f'❌ Handler test failed: {e}')
              import traceback
              traceback.print_exc()
              sys.exit(1)
          "
          
          echo "✅ All Python environment tests passed"

      - name: Build and push Docker image to ECR
        uses: docker/build-push-action@v5
        with:
          context: ./src
          file: ./src/Dockerfile
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      - name: Verify image was pushed successfully
        if: github.event_name != 'pull_request'
        run: |
          echo "🔍 Verifying image was pushed to ECR..."
          IMAGE_URI="${{ steps.get-ecr-uri.outputs.ecr_uri }}:${{ github.event.inputs.image_tag || 'latest' }}"
          
          # Wait a moment for ECR to register the image
          sleep 10
          
          # Check if image exists in ECR
          if aws ecr describe-images --repository-name "hello-world-lambda-${{ github.event.inputs.environment || 'dev' }}" --image-ids imageTag="${{ github.event.inputs.image_tag || 'latest' }}" --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            echo "✅ Image successfully pushed to ECR: $IMAGE_URI"
            
            # Get image details
            IMAGE_DETAILS=$(aws ecr describe-images --repository-name "hello-world-lambda-${{ github.event.inputs.environment || 'dev' }}" --image-ids imageTag="${{ github.event.inputs.image_tag || 'latest' }}" --region ${{ env.AWS_REGION }})
            IMAGE_SIZE=$(echo $IMAGE_DETAILS | jq -r '.imageDetails[0].imageSizeInBytes')
            PUSH_DATE=$(echo $IMAGE_DETAILS | jq -r '.imageDetails[0].imagePushedAt')
            
            echo "📊 Image size: $(($IMAGE_SIZE / 1024 / 1024)) MB"
            echo "📅 Push date: $PUSH_DATE"
          else
            echo "❌ Image not found in ECR after push!"
            echo "Listing all images in repository:"
            aws ecr list-images --repository-name "hello-world-lambda-${{ github.event.inputs.environment || 'dev' }}" --region ${{ env.AWS_REGION }}
            exit 1
          fi

      - name: Image vulnerability scan
        if: github.event_name != 'pull_request'
        run: |
          echo "🔒 Running security scan on Docker image..."
          
          # Install Trivy
          sudo apt-get update
          sudo apt-get install wget apt-transport-https gnupg lsb-release
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
          sudo apt-get update
          sudo apt-get install trivy
          
          # Scan the image
          IMAGE_URI="${{ steps.get-ecr-uri.outputs.ecr_uri }}:${{ github.event.inputs.image_tag || 'latest' }}"
          echo "🔍 Scanning image: $IMAGE_URI"
          trivy image --exit-code 0 --severity HIGH,CRITICAL $IMAGE_URI

      - name: Update Lambda Function with New Image
        if: github.event_name != 'pull_request'
        run: |
          FUNCTION_NAME="hello-world-lambda-${{ github.event.inputs.environment || 'dev' }}"
          IMAGE_URI="${{ steps.get-ecr-uri.outputs.ecr_uri }}:${{ github.event.inputs.image_tag || 'latest' }}"
          
          echo "🚀 Updating Lambda function: $FUNCTION_NAME"
          echo "📦 Using image: $IMAGE_URI"
          
          # Function to check if function exists
          function_exists() {
            aws lambda get-function --function-name $1 --region ${{ env.AWS_REGION }} >/dev/null 2>&1
            return $?
          }
          
          # Function to wait for function deletion
          wait_for_deletion() {
            echo "⏳ Waiting for function deletion to complete..."
            local max_attempts=30
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              if ! function_exists $FUNCTION_NAME; then
                echo "✅ Function successfully deleted after $attempt attempts"
                return 0
              fi
              echo "🔄 Attempt $attempt/$max_attempts: Function still exists, waiting..."
              sleep 5
              attempt=$((attempt + 1))
            done
            
            echo "❌ ERROR: Function deletion timed out after $max_attempts attempts"
            return 1
          }
          
          # Function to wait for function update
          wait_for_update() {
            echo "⏳ Waiting for function update to complete..."
            local max_attempts=30
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              STATUS=$(aws lambda get-function --function-name $FUNCTION_NAME --query 'Configuration.State' --output text --region ${{ env.AWS_REGION }} 2>/dev/null || echo "NotFound")
              LAST_UPDATE_STATUS=$(aws lambda get-function --function-name $FUNCTION_NAME --query 'Configuration.LastUpdateStatus' --output text --region ${{ env.AWS_REGION }} 2>/dev/null || echo "Unknown")
              
              if [ "$STATUS" = "Active" ] && [ "$LAST_UPDATE_STATUS" = "Successful" ]; then
                echo "✅ Function is now active and update successful after $attempt attempts"
                return 0
              fi
              echo "🔄 Attempt $attempt/$max_attempts: Function status is $STATUS, update status is $LAST_UPDATE_STATUS, waiting..."
              sleep 10
              attempt=$((attempt + 1))
            done
            
            echo "❌ ERROR: Function update timed out after $max_attempts attempts"
            return 1
          }
          
          # Check if function exists first
          if function_exists $FUNCTION_NAME; then
            # Check current function configuration
            CURRENT_PACKAGE_TYPE=$(aws lambda get-function --function-name $FUNCTION_NAME --query 'Configuration.PackageType' --output text --region ${{ env.AWS_REGION }})
            echo "📋 Current package type: $CURRENT_PACKAGE_TYPE"
            
            if [ "$CURRENT_PACKAGE_TYPE" = "Zip" ]; then
              echo "🔄 Function is currently ZIP-based, converting to container-based..."
              
              # Get current function configuration
              CURRENT_CONFIG=$(aws lambda get-function-configuration --function-name $FUNCTION_NAME --region ${{ env.AWS_REGION }})
              ROLE_ARN=$(echo $CURRENT_CONFIG | jq -r '.Role')
              TIMEOUT=$(echo $CURRENT_CONFIG | jq -r '.Timeout')
              MEMORY_SIZE=$(echo $CURRENT_CONFIG | jq -r '.MemorySize')
              
              # Extract environment variables and save to file
              echo "💾 Extracting environment variables..."
              echo $CURRENT_CONFIG | jq -c '.Environment.Variables // {}' > /tmp/env_vars.json
              ENV_VARS_CONTENT=$(cat /tmp/env_vars.json)
              
              echo "💾 Backing up current function configuration..."
              echo "🔑 Role: $ROLE_ARN"
              echo "⏱️ Timeout: $TIMEOUT"
              echo "💾 Memory: $MEMORY_SIZE"
              echo "🌍 Environment Variables: $ENV_VARS_CONTENT"
              
              # Delete the existing function
              echo "🗑️ Deleting existing ZIP-based function..."
              aws lambda delete-function --function-name $FUNCTION_NAME --region ${{ env.AWS_REGION }}
              
              # Wait for deletion to complete with proper verification
              if ! wait_for_deletion; then
                echo "❌ ERROR: Failed to delete function, aborting conversion"
                exit 1
              fi
              
              # Create new container-based function with proper environment variables
              echo "🆕 Creating new container-based function..."
              if [ "$ENV_VARS_CONTENT" = "{}" ] || [ "$ENV_VARS_CONTENT" = "null" ]; then
                # No environment variables
                echo "📝 Creating function without environment variables..."
                aws lambda create-function \
                  --function-name $FUNCTION_NAME \
                  --role $ROLE_ARN \
                  --code ImageUri=$IMAGE_URI \
                  --package-type Image \
                  --timeout $TIMEOUT \
                  --memory-size $MEMORY_SIZE \
                  --region ${{ env.AWS_REGION }}
              else
                # With environment variables - use file-based approach
                echo "📝 Creating function with environment variables..."
                
                # Create environment variables in the correct format for AWS CLI
                cat > /tmp/env_config.json << EOF
          {
            "Variables": $(cat /tmp/env_vars.json)
          }
          EOF
                
                echo "📄 Environment config file content:"
                cat /tmp/env_config.json
                
                aws lambda create-function \
                  --function-name $FUNCTION_NAME \
                  --role $ROLE_ARN \
                  --code ImageUri=$IMAGE_URI \
                  --package-type Image \
                  --timeout $TIMEOUT \
                  --memory-size $MEMORY_SIZE \
                  --environment file:///tmp/env_config.json \
                  --region ${{ env.AWS_REGION }}
              fi
              
              # Wait for function to be active
              echo "⏳ Waiting for function to become active..."
              if ! wait_for_update; then
                echo "❌ ERROR: Function creation failed"
                exit 1
              fi
                
            else
              echo "🐳 Function is already container-based, updating image..."
              # Function is already using Image package type, just update the code
              aws lambda update-function-code \
                --function-name $FUNCTION_NAME \
                --image-uri $IMAGE_URI \
                --region ${{ env.AWS_REGION }}
              
              # Wait for the update to complete
              echo "⏳ Waiting for function update to complete..."
              if ! wait_for_update; then
                echo "❌ ERROR: Function update failed"
                exit 1
              fi
            fi
          else
            echo "❌ Function does not exist, creating new container-based function..."
            # Function doesn't exist, create new container-based function
            # We'll need to get the IAM role from Terraform state or create a basic one
            echo "❌ ERROR: Function does not exist and we cannot determine the IAM role"
            echo "Please ensure the Lambda function exists before running this workflow"
            exit 1
          fi
          
          echo "🎉 Lambda function conversion completed successfully"
          
          # Verify the final state
          if function_exists $FUNCTION_NAME; then
            FINAL_PACKAGE_TYPE=$(aws lambda get-function --function-name $FUNCTION_NAME --query 'Configuration.PackageType' --output text --region ${{ env.AWS_REGION }})
            FINAL_IMAGE_URI=$(aws lambda get-function --function-name $FUNCTION_NAME --query 'Code.ImageUri' --output text --region ${{ env.AWS_REGION }})
            FINAL_STATE=$(aws lambda get-function --function-name $FUNCTION_NAME --query 'Configuration.State' --output text --region ${{ env.AWS_REGION }})
            echo "📦 Final package type: $FINAL_PACKAGE_TYPE"
            echo "🖼️ Final image URI: $FINAL_IMAGE_URI"
            echo "🟢 Final state: $FINAL_STATE"
            
            # Test the function
            echo "🧪 Testing the updated function..."
            TEST_RESULT=$(aws lambda invoke \
              --function-name $FUNCTION_NAME \
              --payload '{"httpMethod":"GET","path":"/","headers":{"Accept":"application/json"}}' \
              --region ${{ env.AWS_REGION }} \
              response.json)
            
            if [ $? -eq 0 ]; then
              echo "✅ Function test successful!"
              echo "📄 Response preview:"
              head -c 200 response.json
              echo ""
              echo "🌐 You can now test your updated function via API Gateway!"
            else
              echo "⚠️ Function test failed, but deployment completed"
            fi
          else
            echo "❌ ERROR: Function verification failed - function does not exist after creation"
            exit 1
          fi

    outputs:
      image_uri: ${{ steps.get-ecr-uri.outputs.ecr_uri }}:${{ github.event.inputs.image_tag || 'latest' }}