name: Build and Push Docker Image

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod
      image_tag:
        description: 'Docker image tag'
        required: false
        default: 'latest'
        type: string
  push:
    branches:
      - main
    paths:
      - 'src/**'
  pull_request:
    branches:
      - main
    paths:
      - 'src/**'

env:
  AWS_REGION: ap-south-1

permissions:
  id-token: write
  contents: read

jobs:
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'dev' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::199570228070:role/oidc-demo-role
          role-session-name: GitHubActions-Build-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get ECR Repository URI
        id: get-ecr-uri
        run: |
          # Get ECR repository URI from AWS
          REPO_NAME="hello-world-lambda-${{ github.event.inputs.environment || 'dev' }}"
          ECR_URI=$(aws ecr describe-repositories --repository-names $REPO_NAME --query 'repositories[0].repositoryUri' --output text)
          echo "ecr_uri=$ECR_URI" >> $GITHUB_OUTPUT
          echo "üì¶ ECR Repository URI: $ECR_URI"

      - name: Verify ECR Repository Exists
        run: |
          REPO_NAME="hello-world-lambda-${{ github.event.inputs.environment || 'dev' }}"
          echo "üîç Verifying ECR repository exists..."
          
          if aws ecr describe-repositories --repository-names $REPO_NAME --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            echo "‚úÖ ECR repository '$REPO_NAME' exists"
          else
            echo "‚ùå ECR repository '$REPO_NAME' does not exist!"
            echo "Please run the ECR workflow first to create the repository"
            exit 1
          fi

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.get-ecr-uri.outputs.ecr_uri }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=${{ github.event.inputs.image_tag || 'latest' }}
            type=raw,value={{date 'YYYYMMDD-HHmmss'}}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Validate Python Code Before Building
        run: |
          echo "üîç Validating Python code syntax and imports..."
          
          # Change to src directory where app.py is located
          cd src
          
          # Check if app.py exists
          if [ ! -f "app.py" ]; then
            echo "‚ùå app.py not found in src directory"
            ls -la
            exit 1
          fi
          
          echo "‚úÖ app.py found"
          
          # Check Python syntax
          echo "üìù Checking Python syntax..."
          python3 -m py_compile app.py
          echo "‚úÖ Python syntax is valid"
          
          # Check if required modules can be imported
          echo "üì¶ Testing module imports..."
          python3 -c "
          import json
          import logging
          print('‚úÖ Standard library imports successful')
          "
          
          # Test the handler function structure with proper path handling
          echo "üéØ Validating handler function..."
          python3 -c "
          import sys
          import os
          
          # Add current directory to Python path
          current_dir = os.getcwd()
          if current_dir not in sys.path:
              sys.path.insert(0, current_dir)
          
          print(f'Current directory: {current_dir}')
          print(f'Python path: {sys.path[:3]}...')
          
          try:
              import app
              print('‚úÖ App module imported successfully')
          except ImportError as e:
              print(f'‚ùå Failed to import app module: {e}')
              print('Files in current directory:')
              import os
              for f in os.listdir('.'):
                  print(f'  {f}')
              sys.exit(1)
          
          # Check if lambda_handler exists
          if not hasattr(app, 'lambda_handler'):
              print('‚ùå lambda_handler function not found in app module')
              print(f'Available attributes: {[attr for attr in dir(app) if not attr.startswith(\"_\")]}')
              sys.exit(1)
          
          # Check if it's callable
          if not callable(app.lambda_handler):
              print('‚ùå lambda_handler is not callable')
              print(f'lambda_handler type: {type(app.lambda_handler)}')
              sys.exit(1)
          
          # Check function signature
          import inspect
          try:
              sig = inspect.signature(app.lambda_handler)
              params = list(sig.parameters.keys())
              
              if len(params) != 2:
                  print(f'‚ùå lambda_handler should have 2 parameters, found {len(params)}: {params}')
                  sys.exit(1)
              
              print(f'‚úÖ lambda_handler function has correct signature: {params}')
              
          except Exception as e:
              print(f'‚ùå Error checking function signature: {e}')
              sys.exit(1)
          
          print('‚úÖ lambda_handler function is valid and callable')
          "
          
          echo "‚úÖ All Python validation checks passed"

      - name: Build Docker image locally first
        run: |
          echo "üî® Building Docker image locally for validation..."
          cd src
          
          # Build with explicit platform for Lambda compatibility
          docker build \
            --platform linux/amd64 \
            --tag test-lambda-image \
            --file Dockerfile \
            .
          
          echo "‚úÖ Local build successful"

      - name: Validate Docker Image Structure
        run: |
          echo "üß™ Validating Docker image structure..."
          
          # Check that the image was built successfully
          if docker images test-lambda-image | grep -q test-lambda-image; then
            echo "‚úÖ Docker image exists"
          else
            echo "‚ùå Docker image not found"
            exit 1
          fi
          
          # Check image architecture
          ARCH=$(docker inspect test-lambda-image --format='{{.Architecture}}')
          echo "üèóÔ∏è Image architecture: $ARCH"
          
          if [ "$ARCH" != "amd64" ]; then
            echo "‚ùå Image architecture should be amd64 for Lambda compatibility"
            exit 1
          fi
          
          # Check image size
          IMAGE_SIZE=$(docker images test-lambda-image --format "table {{.Size}}" | tail -n 1)
          echo "üìä Image size: $IMAGE_SIZE"
          
          # Verify the image contains our files
          echo "üìÅ Checking image contents..."
          docker run --rm --platform linux/amd64 --entrypoint="" test-lambda-image ls -la /var/task/
          
          # Check that Python files are present
          echo "üêç Verifying Python files..."
          if docker run --rm --platform linux/amd64 --entrypoint="" test-lambda-image test -f /var/task/app.py; then
            echo "‚úÖ app.py found in image"
          else
            echo "‚ùå app.py not found in image"
            exit 1
          fi
          
          # Check requirements.txt if it exists
          if docker run --rm --platform linux/amd64 --entrypoint="" test-lambda-image test -f /var/task/requirements.txt; then
            echo "‚úÖ requirements.txt found in image"
            echo "üìã Requirements content:"
            docker run --rm --platform linux/amd64 --entrypoint="" test-lambda-image cat /var/task/requirements.txt
          else
            echo "‚ÑπÔ∏è requirements.txt not found (optional)"
          fi
          
          echo "‚úÖ Docker image structure validation passed"

      - name: Test Python Environment in Container
        run: |
          echo "üêç Testing Python environment in container..."
          
          # Test Python version
          echo "üìã Python version:"
          docker run --rm --platform linux/amd64 --entrypoint="" test-lambda-image python --version
          
          # Test that our module can be imported in the container
          echo "üì¶ Testing module import in container..."
          docker run --rm --platform linux/amd64 --entrypoint="" test-lambda-image python -c "
          import sys
          import os
          
          # The Lambda runtime sets LAMBDA_TASK_ROOT
          task_root = '/var/task'
          if task_root not in sys.path:
              sys.path.insert(0, task_root)
          
          print(f'Task root: {task_root}')
          print(f'Python path: {sys.path[:3]}...')
          
          try:
              import app
              print('‚úÖ App module imports successfully in container')
          except Exception as e:
              print(f'‚ùå App module import failed: {e}')
              print('Files in task root:')
              for f in os.listdir(task_root):
                  print(f'  {f}')
              sys.exit(1)
          
          # Verify lambda_handler exists and is callable
          if not hasattr(app, 'lambda_handler'):
              print('‚ùå lambda_handler function not found in container')
              print(f'Available attributes: {[attr for attr in dir(app) if not attr.startswith(\"_\")]}')
              sys.exit(1)
          
          if not callable(app.lambda_handler):
              print('‚ùå lambda_handler is not callable in container')
              sys.exit(1)
          
          print('‚úÖ lambda_handler function is accessible in container')
          "
          
          # Test boto3 availability (should be included in Lambda base image)
          echo "üîß Testing boto3 availability..."
          docker run --rm --platform linux/amd64 --entrypoint="" test-lambda-image python -c "
          try:
              import boto3
              print('‚úÖ boto3 is available')
              print(f'boto3 version: {boto3.__version__}')
          except Exception as e:
              print(f'‚ùå boto3 import failed: {e}')
              sys.exit(1)
          "
          
          echo "‚úÖ All Python environment tests passed"

      - name: Test Lambda Runtime Interface
        run: |
          echo "üîß Testing Lambda Runtime Interface..."
          
          # Test that the CMD is properly set
          CMD=$(docker inspect test-lambda-image --format='{{.Config.Cmd}}')
          echo "üìã Container CMD: $CMD"
          
          if [[ "$CMD" != *"app.lambda_handler"* ]]; then
            echo "‚ùå Container CMD should reference app.lambda_handler"
            exit 1
          fi
          
          # Test the Lambda runtime interface emulator (if available)
          echo "üß™ Testing Lambda handler invocation..."
          docker run --rm --platform linux/amd64 --entrypoint="" test-lambda-image python -c "
          import app
          import json
          
          # Mock event and context
          event = {
              'httpMethod': 'GET',
              'path': '/',
              'headers': {'Accept': 'application/json'},
              'queryStringParameters': None
          }
          
          class MockContext:
              def __init__(self):
                  self.function_name = 'test-function'
                  self.function_version = '\$LATEST'
                  self.memory_limit_in_mb = '256'
                  self.aws_request_id = 'test-request-id'
              
              def get_remaining_time_in_millis(self):
                  return 30000
          
          context = MockContext()
          
          try:
              response = app.lambda_handler(event, context)
              print('‚úÖ Lambda handler executed successfully')
              print(f'üìä Response status: {response.get(\"statusCode\", \"N/A\")}')
              print(f'üìÑ Response type: {type(response)}')
              
              # Validate response structure
              required_keys = ['statusCode', 'headers', 'body']
              for key in required_keys:
                  if key not in response:
                      print(f'‚ùå Missing required key: {key}')
                      sys.exit(1)
              
              print('‚úÖ Response structure is valid')
              
          except Exception as e:
              print(f'‚ùå Lambda handler test failed: {e}')
              import traceback
              traceback.print_exc()
              sys.exit(1)
          "
          
          echo "‚úÖ Lambda runtime interface test passed"

      - name: Run Local Lambda Function Test
        run: |
          echo "üß™ Running comprehensive Lambda function test..."
          cd src
          
          # Run the local test script
          python3 test_lambda_local.py
          
          echo "‚úÖ Local Lambda function test completed successfully"

      - name: Build and push Docker image to ECR
        uses: docker/build-push-action@v5
        with:
          context: ./src
          file: ./src/Dockerfile
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64
          provenance: false
          sbom: false

      - name: Verify image was pushed successfully
        if: github.event_name != 'pull_request'
        run: |
          echo "üîç Verifying image was pushed to ECR..."
          IMAGE_URI="${{ steps.get-ecr-uri.outputs.ecr_uri }}:${{ github.event.inputs.image_tag || 'latest' }}"
          
          # Wait a moment for ECR to register the image
          sleep 15
          
          # Check if image exists in ECR
          if aws ecr describe-images --repository-name "hello-world-lambda-${{ github.event.inputs.environment || 'dev' }}" --image-ids imageTag="${{ github.event.inputs.image_tag || 'latest' }}" --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            echo "‚úÖ Image successfully pushed to ECR: $IMAGE_URI"
            
            # Get image details
            IMAGE_DETAILS=$(aws ecr describe-images --repository-name "hello-world-lambda-${{ github.event.inputs.environment || 'dev' }}" --image-ids imageTag="${{ github.event.inputs.image_tag || 'latest' }}" --region ${{ env.AWS_REGION }})
            IMAGE_SIZE=$(echo $IMAGE_DETAILS | jq -r '.imageDetails[0].imageSizeInBytes')
            PUSH_DATE=$(echo $IMAGE_DETAILS | jq -r '.imageDetails[0].imagePushedAt')
            IMAGE_DIGEST=$(echo $IMAGE_DETAILS | jq -r '.imageDetails[0].imageDigest')
            
            echo "üìä Image size: $(($IMAGE_SIZE / 1024 / 1024)) MB"
            echo "üìÖ Push date: $PUSH_DATE"
            echo "üîç Image digest: $IMAGE_DIGEST"
            
            # Verify image manifest
            echo "üîç Verifying image manifest..."
            MANIFEST=$(aws ecr batch-get-image --repository-name "hello-world-lambda-${{ github.event.inputs.environment || 'dev' }}" --image-ids imageTag="${{ github.event.inputs.image_tag || 'latest' }}" --query 'images[0].imageManifest' --output text --region ${{ env.AWS_REGION }})
            
            if [ "$MANIFEST" != "None" ] && [ "$MANIFEST" != "" ]; then
              echo "‚úÖ Image manifest is valid"
            else
              echo "‚ùå Image manifest is invalid or missing"
              exit 1
            fi
            
          else
            echo "‚ùå Image not found in ECR after push!"
            echo "Listing all images in repository:"
            aws ecr list-images --repository-name "hello-world-lambda-${{ github.event.inputs.environment || 'dev' }}" --region ${{ env.AWS_REGION }}
            exit 1
          fi

      # - name: Image vulnerability scan
      #   if: github.event_name != 'pull_request'
      #   run: |
      #     echo "üîí Running security scan on Docker image..."
          
      #     # Install Trivy
      #     sudo apt-get update
      #     sudo apt-get install wget apt-transport-https gnupg lsb-release
      #     wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
      #     echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
      #     sudo apt-get update
      #     sudo apt-get install trivy
          
      #     # Scan the image
      #     IMAGE_URI="${{ steps.get-ecr-uri.outputs.ecr_uri }}:${{ github.event.inputs.image_tag || 'latest' }}"
      #     echo "üîç Scanning image: $IMAGE_URI"
      #     trivy image --exit-code 0 --severity HIGH,CRITICAL $IMAGE_URI

    outputs:
      image_uri: ${{ steps.get-ecr-uri.outputs.ecr_uri }}:${{ github.event.inputs.image_tag || 'latest' }}