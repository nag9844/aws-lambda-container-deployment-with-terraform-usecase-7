name: Infrastructure Deployment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod
      action:
        description: 'Terraform action'
        required: true
        default: 'plan'
        type: choice
        options:
        - plan
        - apply
        - destroy
  push:
    branches:
      - main
    paths:
      - 'terraform/**'
      - 'src/**'
  pull_request:
    branches:
      - main
    paths:
      - 'terraform/**'

env:
  AWS_REGION: ap-south-1
  TF_VAR_aws_region: ap-south-1

permissions:
  id-token: write
  contents: read
  pull-requests: write

jobs:
  terraform-validate:
    name: Terraform Validate
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        # with:
        #   terraform_version: 1.6.0

      - name: Terraform Format Check
        run: |
          terraform fmt -check -recursive terraform/
          
      - name: Terraform Validate - All Modules
        run: |
          for module in terraform/modules/*/; do
            echo "Validating $module"
            cd $module
            terraform init -backend=false
            terraform validate
            cd - > /dev/null
          done

  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'dev' }}
    if: github.event_name == 'pull_request' || github.event.inputs.action == 'plan'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::199570228070:role/oidc-demo-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
          terraform_wrapper: false

      - name: Terraform Init
        working-directory: terraform/environments/${{ github.event.inputs.environment || 'dev' }}
        run: |
          terraform init \
            -backend-config="bucket=${{ vars.TERRAFORM_STATE_BUCKET }}" \
            -backend-config="key=${{ github.event.inputs.environment || 'dev' }}/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="encrypt=true"

      - name: Terraform Plan
        id: plan
        working-directory: terraform/environments/${{ github.event.inputs.environment || 'dev' }}
        run: |
          terraform plan -detailed-exitcode -out=tfplan
          echo "plan_exitcode=$?" >> $GITHUB_OUTPUT

      - name: Save Plan Output
        if: github.event_name == 'pull_request'
        working-directory: terraform/environments/${{ github.event.inputs.environment || 'dev' }}
        run: |
          terraform show -no-color tfplan > plan_output.txt

      - name: Comment Plan on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = './terraform/environments/${{ github.event.inputs.environment || 'dev' }}/plan_output.txt';
            const plan = fs.readFileSync(path, 'utf8');
            
            const comment = `
            ## Terraform Plan - ${{ github.event.inputs.environment || 'dev' }} Environment
            
            <details>
            <summary>Show Plan</summary>
            
            \`\`\`hcl
            ${plan}
            \`\`\`
            
            </details>
            
            **Plan Status**: ${{ steps.plan.outputs.plan_exitcode == '2' && 'Changes Detected' || 'No Changes' }}
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  # Step 1: Deploy Infrastructure (creates Lambda with ZIP deployment)
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'dev' }}
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::199570228070:role/oidc-demo-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
          terraform_wrapper: false

      - name: Terraform Init
        working-directory: terraform/environments/${{ github.event.inputs.environment || 'dev' }}
        run: |
          terraform init \
            -backend-config="bucket=${{ vars.TERRAFORM_STATE_BUCKET }}" \
            -backend-config="key=${{ github.event.inputs.environment || 'dev' }}/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="encrypt=true"

      - name: Terraform Apply
        working-directory: terraform/environments/${{ github.event.inputs.environment || 'dev' }}
        run: terraform apply -auto-approve

      - name: Get Outputs
        id: outputs
        working-directory: terraform/environments/${{ github.event.inputs.environment || 'dev' }}
        run: |
          API_URL=$(terraform output -raw api_gateway_url 2>/dev/null || echo "")
          LAMBDA_ARN=$(terraform output -raw lambda_function_arn 2>/dev/null || echo "")
          LAMBDA_NAME=$(terraform output -raw lambda_function_name 2>/dev/null || echo "")
          echo "api_url=$API_URL" >> $GITHUB_OUTPUT
          echo "lambda_arn=$LAMBDA_ARN" >> $GITHUB_OUTPUT
          echo "lambda_name=$LAMBDA_NAME" >> $GITHUB_OUTPUT

      - name: Test Initial Deployment
        if: steps.outputs.outputs.api_url != ''
        run: |
          echo "ðŸ§ª Testing initial Lambda deployment..."
          echo "ðŸŒ API Gateway URL: ${{ steps.outputs.outputs.api_url }}"
          
          # Wait for API Gateway to be ready
          sleep 15
          
          # Test the endpoint
          RESPONSE=$(curl -s -w "\n%{http_code}" "${{ steps.outputs.outputs.api_url }}")
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "âœ… Initial deployment test successful!"
          else
            echo "âš ï¸ Initial deployment returned HTTP $HTTP_CODE - function may need more time to initialize"
          fi

    outputs:
      api_url: ${{ steps.outputs.outputs.api_url }}
      lambda_arn: ${{ steps.outputs.outputs.lambda_arn }}
      lambda_name: ${{ steps.outputs.outputs.lambda_name }}

  # Step 2: Build and Deploy Container Image
  build-and-deploy-container:
    name: Build and Deploy Container
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'dev' }}
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    needs: [deploy-infrastructure]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::199570228070:role/oidc-demo-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get ECR Repository URI
        id: get-ecr-uri
        run: |
          REPO_NAME="hello-world-lambda-${{ github.event.inputs.environment || 'dev' }}"
          ECR_URI=$(aws ecr describe-repositories --repository-names $REPO_NAME --query 'repositories[0].repositoryUri' --output text)
          echo "ecr_uri=$ECR_URI" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ ECR Repository URI: $ECR_URI"

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.get-ecr-uri.outputs.ecr_uri }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest
            type=raw,value={{date 'YYYYMMDD-HHmmss'}}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./src
          file: ./src/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      - name: Convert Lambda to Container Mode
        run: |
          FUNCTION_NAME="${{ needs.deploy-infrastructure.outputs.lambda_name }}"
          IMAGE_URI="${{ steps.get-ecr-uri.outputs.ecr_uri }}:latest"
          
          echo "ðŸš€ Converting Lambda function to container mode"
          echo "ðŸ“¦ Function: $FUNCTION_NAME"
          echo "ðŸ–¼ï¸ Image: $IMAGE_URI"
          
          # Function to check if function exists
          function_exists() {
            aws lambda get-function --function-name $1 --region ${{ env.AWS_REGION }} >/dev/null 2>&1
            return $?
          }
          
          # Function to wait for function deletion
          wait_for_deletion() {
            echo "â³ Waiting for function deletion to complete..."
            local max_attempts=30
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              if ! function_exists $FUNCTION_NAME; then
                echo "âœ… Function successfully deleted after $attempt attempts"
                return 0
              fi
              echo "ðŸ”„ Attempt $attempt/$max_attempts: Function still exists, waiting..."
              sleep 5
              attempt=$((attempt + 1))
            done
            
            echo "âŒ ERROR: Function deletion timed out after $max_attempts attempts"
            return 1
          }
          
          # Function to wait for function to be active
          wait_for_active() {
            echo "â³ Waiting for function to become active..."
            local max_attempts=30
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              STATUS=$(aws lambda get-function --function-name $FUNCTION_NAME --query 'Configuration.State' --output text --region ${{ env.AWS_REGION }} 2>/dev/null || echo "NotFound")
              if [ "$STATUS" = "Active" ]; then
                echo "âœ… Function is now active after $attempt attempts"
                return 0
              fi
              echo "ðŸ”„ Attempt $attempt/$max_attempts: Function status is $STATUS, waiting..."
              sleep 10
              attempt=$((attempt + 1))
            done
            
            echo "âŒ ERROR: Function activation timed out after $max_attempts attempts"
            return 1
          }
          
          # Verify function exists
          if ! function_exists $FUNCTION_NAME; then
            echo "âŒ ERROR: Function $FUNCTION_NAME does not exist!"
            echo "Please ensure the infrastructure deployment completed successfully"
            exit 1
          fi
          
          # Get current function configuration
          echo "ðŸ“‹ Getting current function configuration..."
          CURRENT_CONFIG=$(aws lambda get-function-configuration --function-name $FUNCTION_NAME --region ${{ env.AWS_REGION }})
          CURRENT_PACKAGE_TYPE=$(echo $CURRENT_CONFIG | jq -r '.PackageType')
          ROLE_ARN=$(echo $CURRENT_CONFIG | jq -r '.Role')
          TIMEOUT=$(echo $CURRENT_CONFIG | jq -r '.Timeout')
          MEMORY_SIZE=$(echo $CURRENT_CONFIG | jq -r '.MemorySize')
          ENV_VARS_JSON=$(echo $CURRENT_CONFIG | jq -c '.Environment.Variables // {}')
          
          echo "ðŸ“¦ Current package type: $CURRENT_PACKAGE_TYPE"
          echo "ðŸ”‘ Role: $ROLE_ARN"
          echo "â±ï¸ Timeout: $TIMEOUT"
          echo "ðŸ’¾ Memory: $MEMORY_SIZE"
          echo "ðŸŒ Environment Variables: $ENV_VARS_JSON"
          
          if [ "$CURRENT_PACKAGE_TYPE" = "Image" ]; then
            echo "ðŸ³ Function is already container-based, updating image..."
            aws lambda update-function-code \
              --function-name $FUNCTION_NAME \
              --image-uri $IMAGE_URI \
              --region ${{ env.AWS_REGION }}
            
            if ! wait_for_active; then
              echo "âŒ ERROR: Function update failed"
              exit 1
            fi
          else
            echo "ðŸ”„ Function is ZIP-based, converting to container..."
            
            # Delete existing function
            echo "ðŸ—‘ï¸ Deleting existing ZIP-based function..."
            aws lambda delete-function --function-name $FUNCTION_NAME --region ${{ env.AWS_REGION }}
            
            # Wait for deletion
            if ! wait_for_deletion; then
              echo "âŒ ERROR: Failed to delete function"
              exit 1
            fi
            
            # Create new container-based function
            echo "ðŸ†• Creating new container-based function..."
            
            if [ "$ENV_VARS_JSON" = "{}" ] || [ "$ENV_VARS_JSON" = "null" ]; then
              # No environment variables
              aws lambda create-function \
                --function-name $FUNCTION_NAME \
                --role $ROLE_ARN \
                --code ImageUri=$IMAGE_URI \
                --package-type Image \
                --timeout $TIMEOUT \
                --memory-size $MEMORY_SIZE \
                --region ${{ env.AWS_REGION }}
            else
              # With environment variables
              echo "$ENV_VARS_JSON" > /tmp/env_vars.json
              cat > /tmp/env_config.json << EOF
          {
            "Variables": $(cat /tmp/env_vars.json)
          }
          EOF
              
              echo "ðŸ“„ Environment config:"
              cat /tmp/env_config.json
              
              aws lambda create-function \
                --function-name $FUNCTION_NAME \
                --role $ROLE_ARN \
                --code ImageUri=$IMAGE_URI \
                --package-type Image \
                --timeout $TIMEOUT \
                --memory-size $MEMORY_SIZE \
                --environment file:///tmp/env_config.json \
                --region ${{ env.AWS_REGION }}
            fi
            
            # Wait for function to be active
            if ! wait_for_active; then
              echo "âŒ ERROR: Function creation failed"
              exit 1
            fi
          fi
          
          # Verify final state
          echo "ðŸ” Verifying final state..."
          FINAL_CONFIG=$(aws lambda get-function --function-name $FUNCTION_NAME --region ${{ env.AWS_REGION }})
          FINAL_PACKAGE_TYPE=$(echo $FINAL_CONFIG | jq -r '.Configuration.PackageType')
          FINAL_IMAGE_URI=$(echo $FINAL_CONFIG | jq -r '.Code.ImageUri // "N/A"')
          FINAL_STATE=$(echo $FINAL_CONFIG | jq -r '.Configuration.State')
          
          echo "âœ… Conversion completed successfully!"
          echo "ðŸ“¦ Final package type: $FINAL_PACKAGE_TYPE"
          echo "ðŸ–¼ï¸ Final image URI: $FINAL_IMAGE_URI"
          echo "ðŸŸ¢ Final state: $FINAL_STATE"

      - name: Test Updated Function
        run: |
          echo "ðŸ§ª Testing updated container-based function..."
          API_URL="${{ needs.deploy-infrastructure.outputs.api_url }}"
          
          if [ -n "$API_URL" ]; then
            echo "ðŸŒ Testing API Gateway endpoint: $API_URL"
            
            # Wait for API Gateway to recognize the updated function
            sleep 20
            
            # Test the endpoint multiple times to ensure consistency
            for i in {1..3}; do
              echo "ðŸ”„ Test attempt $i/3..."
              RESPONSE=$(curl -s -w "\n%{http_code}" "$API_URL")
              HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
              BODY=$(echo "$RESPONSE" | head -n -1)
              
              echo "ðŸ“Š HTTP Status: $HTTP_CODE"
              
              if [ "$HTTP_CODE" = "200" ]; then
                echo "âœ… Function test successful!"
                echo "ðŸ“„ Response preview:"
                echo "$BODY" | head -c 300
                echo ""
                echo ""
                echo "ðŸŽ‰ Container deployment completed successfully!"
                echo "ðŸŒ Your updated function is live at: $API_URL"
                break
              else
                echo "âš ï¸ Test $i failed with HTTP $HTTP_CODE"
                if [ $i -lt 3 ]; then
                  echo "Waiting 10 seconds before retry..."
                  sleep 10
                fi
              fi
            done
          else
            echo "âš ï¸ API Gateway URL not available for testing"
          fi

  # Manual apply job for workflow dispatch
  terraform-apply-manual:
    name: Terraform Apply (Manual)
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'dev' }}
    if: github.event.inputs.action == 'apply'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::199570228070:role/oidc-demo-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        # with:
        #   terraform_version: 1.6.0
        #   terraform_wrapper: false

      - name: Terraform Init
        working-directory: terraform/environments/${{ github.event.inputs.environment || 'dev' }}
        run: |
          terraform init \
            -backend-config="bucket=${{ vars.TERRAFORM_STATE_BUCKET }}" \
            -backend-config="key=${{ github.event.inputs.environment || 'dev' }}/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="encrypt=true"

      - name: Terraform Apply
        working-directory: terraform/environments/${{ github.event.inputs.environment || 'dev' }}
        run: terraform apply -auto-approve

      - name: Get Outputs
        id: outputs
        working-directory: terraform/environments/${{ github.event.inputs.environment || 'dev' }}
        run: |
          API_URL=$(terraform output -raw api_gateway_url 2>/dev/null || echo "")
          LAMBDA_ARN=$(terraform output -raw lambda_function_arn 2>/dev/null || echo "")
          echo "api_url=$API_URL" >> $GITHUB_OUTPUT
          echo "lambda_arn=$LAMBDA_ARN" >> $GITHUB_OUTPUT

      - name: Test Deployment
        if: steps.outputs.outputs.api_url != ''
        run: |
          echo "Testing API Gateway endpoint..."
          curl -f "${{ steps.outputs.outputs.api_url }}" || exit 1
          echo "Deployment test successful!"

    outputs:
      api_url: ${{ steps.outputs.outputs.api_url }}
      lambda_arn: ${{ steps.outputs.outputs.lambda_arn }}

  terraform-destroy:
    name: Terraform Destroy
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'dev' }}
    if: github.event.inputs.action == 'destroy'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::199570228070:role/oidc-demo-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        # with:
        #   terraform_version: 1.6.0

      - name: Terraform Init
        working-directory: terraform/environments/${{ github.event.inputs.environment || 'dev' }}
        run: |
          terraform init \
            -backend-config="bucket=${{ vars.TERRAFORM_STATE_BUCKET }}" \
            -backend-config="key=${{ github.event.inputs.environment || 'dev' }}/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="encrypt=true"

      - name: Terraform Destroy
        working-directory: terraform/environments/${{ github.event.inputs.environment || 'dev' }}
        run: terraform destroy -auto-approve